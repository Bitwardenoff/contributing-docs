import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Evolutionary database design

At Bitwarden we follow
[Evolutionary Database Design (EDD)](https://en.wikipedia.org/wiki/Evolutionary_database_design).
EDD describes a process where the database schema is continuously updated while still ensuring
compatibility with older releases by using database transition phases.

Additional requirements include:

- **Zero-downtime deployments**: Which means that multiple versions of the application will be
  running concurrently during the deployment window.
- **Code rollback**: Critical defects in code should be able to be rolled back to the previous
  version.

To fulfill these additional requirements the database schema **must** support the previous release
of the server.

<bitwarden>

:::note

For background on this decision please see the [Evolutionary Database Design RFD][edd-rfd].

:::

</bitwarden>

## Design

Database changes can be categorized into two categories: destructive and non-destructive
\[[1](./edd#further-reading)\]. A destructive change prevents existing functionality from working as
expected without an accompanying code change. A non-destructive change is one that does not require
a code change to allow the application to continue working as expected.

### Non-destructive database changes

Non-destructive changes almost always use either nullable fields or default values in the database
tables, views, and stored procedures. This ensures that the stored procedures can be called without
the new columns which allows it to run with both the old and new code.

### Destructive changes

Destructive database changes are handled elegantly by breaking them up into three phases: _Start_,
_Transition_ and _End_.

<div style="margin: 1em">
  <img src="./stages_refactoring.jpg" alt="Refactoring Phases" />
  <div style="fontSize: 12, textAlign: center">
    Refactoring Phases: [
    <a href="https://martinfowler.com/articles/evodb.html">
      https://martinfowler.com/articles/evodb.html
    </a>
    ]
  </div>
</div>

To add terminology to compliment the [above diagram](./edd#destructive-changes), migrations that are
a part of "Deploy new changes, migrate data, put in scaffolding code" are considered _Initial_
migrations. Migrations that are run during the Transition Phase are considered _Transition_
migrations. And the migrations that run as a part of "Remove old schema, scaffolding code" are
considered _Finalization_ migrations. The definitions of each are helpful when discussing the type
of migration in relation to orchestrating them during a deployment.

### Initial migrations

- Compatible with _X.1.0_ **and** _X.2.0_ application code changes
- Represents the beginning of a database change
- Updates the database schema to support any new functionality while also maintaining old
  functionality
- Supports both the previous version of code and the one being upgraded to
- Run during upgrade
- Must execute quickly to minimize downtime.

### Transition migrations

- Compatible with _X.1.0_ **and** _X.2.0_ application code changes
- The time between initial migration and finalization migration
- Exists to provide an opportunity to rollback server to _X.1.0_ version prior to breaking changes
- Only data population migrations may be run at this time, if they are needed
  - Optional step, required only when migrating data would be too slow to execute during the initial
    migration. This might be a column population, index creation, anything to prepare the database
    for the _X.2.0_ version
  - Must be run as a background task during the Transition phase.
  - These MUST run in a way where the database stays responsive during the full migration
- Schema changes are NOT to be run during this phase.

### Finalization migrations

- Only compatible with _X.2.0_ application code; represents the point of no return for this
  migration
- Removes columns, data, and fallback code required to support _X.1.0_ version
- Should be run as a typical migration either during a subsequent upgrade

### Example

Letâ€™s look at an example, the rename column refactor is shown in the image below.

![Rename Column Refactor](./rename-column.gif)

In this refactor we rename the column `Fname` in the `Customer` table to `FirstName`. This could
easily be achieved using a regular `Alter Table` statement but that would break compatibility with
existing running code. Instead let's look at how we can incrementally refactor this table.

We will begin by creating a migration which adds the column `FirstName` to the `Customer` Table. At
the same time we will also update the Stored Procedures to sync the content between `FName` and
`FirstName` which ensures both the old and new server releases can run at the same time. The sync
code is highlighted in the code snippet below.

Afterwards the new server version will be deployed, once everything checks out the existing data
will be migrated using a _Data Migration_ script. Which essentially copies the `FName` to
`FirstName` columns.

Lastly the _Second Migration_ will be run which removes the old column and updates the Stored
Procedure to remove the synchronization logic.

#### Migrations

:::note

All database migrations should support being run multiple times; even if subsequent runs perform no
actions.

:::

<Tabs>
<TabItem value="first" label="Initial Migration" default>

```sql
-- Add Column
IF COL_LENGTH('[dbo].[Customer]', 'FirstName') IS NULL
BEGIN
    ALTER TABLE
        [dbo].[Customer]
    ADD
        [FirstName] NVARCHAR(MAX) NULL
END
GO

-- Drop existing SPROC
IF OBJECT_ID('[dbo].[Customer_Create]') IS NOT NULL
BEGIN
    DROP PROCEDURE [dbo].[Customer_Create]
END
GO

-- Create the new SPROC
CREATE PROCEDURE [dbo].[Customer_Create]
    @CustomerId UNIQUEIDENTIFIER OUTPUT,
    @FName NVARCHAR(MAX) = NULL, -- Deprecated as of YYYY-MM-DD
    @FirstName NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON

    SET @FirstName = COALESCE(@FirstName, @FName);

    INSERT INTO [dbo].[Customer]
    (
        [CustomerId],
        [FName],
        [FirstName]
    )
    VALUES
    (
        @CustomerId,
        @FirstName,
        @FirstName
    )
END
```

</TabItem>
<TabItem value="data" label="Transition Migration">

```sql
UPDATE [dbo].Customer SET
    FirstName=FName
WHERE FirstName IS NULL
```

</TabItem>
<TabItem value="second" label="Finalization Migration">

```sql
-- Remove Column
IF COL_LENGTH('[dbo].[Customer]', 'FName') IS NOT NULL
BEGIN
    ALTER TABLE
        [dbo].[Customer]
    DROP COLUMN
        [FName]
END
GO

-- Drop existing SPROC
IF OBJECT_ID('[dbo].[Customer_Create]') IS NOT NULL
BEGIN
    DROP PROCEDURE [dbo].[Customer_Create]
END
GO

-- Create the new SPROC
CREATE PROCEDURE [dbo].[Customer_Create]
    @CustomerId UNIQUEIDENTIFIER OUTPUT,
    @FirstName NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON

    INSERT INTO [dbo].[Customer]
    (
        [CustomerId],
        [FirstName]
    )
    VALUES
    (
        @CustomerId,
        @FirstName
    )
END
```

</TabItem>
</Tabs>

## Deployment orchestration

There are some important constraints to the implementation of the process:

- Bitwarden Production environments are required to be on at all times
- Self-host instances must support the same database change process; however, they do not have the
  same always-on application constraint
- Minimization of manual steps in the process

The process to support all of these constraints is a complex one. Below is an image of a state
machine that will hopefully help visualize the process and what it supports. It assumes that all
database changes follow the standards that are laid out in [Migrations](./).

---

![Bitwarden EDD State Machine](./edd_state_machine.jpg) \[Open Image in a new tab for better
viewing\]

---

### Online environments

Schema migrations and data migrations as just migrations. The underlying implementation issue is
orchestrating the runtime constraints on the migration. Eventually, all migrations will end up in
`DbScripts`. However, to orchestrate the running of _Transition_ and associated _Finalization_
migrations, they are kept outside of `DbScripts` until the correct timing.

In environments with always-on applications, _Transition_ scripts must be run after the new code has
been rolled out. To execute a full deploy, all new migrations in `DbScripts` are run, the new code
is rolled out, and then all _Transition_ migrations in the `DbScripts_transition` directory are run
as soon as all of the new code services are online. In the case of a critical failure after the new
code is rolled out, a Rollback would be conducted (see Rollbacks below). _Finalization_ migrations
will not be run until the start of the next deploy when they are moved into `DbScripts`.

After this deploy, to prep for the next release, all migrations in `DbScripts_transition` are moved
to `DbScripts` and then all migrations in `DbScripts_finalization` are moved to `DbScripts`,
conserving their execution order for a clean install. For the current branching strategy, PRs will
be open against `master` when `rc` is cut to prep for this release. This PR automation will also
handle renaming the migration file and updating any reference of `[dbo_finalization]` to `[dbo]`.

The next deploy will pick up the newly added migrations in `DbScripts` and set the previously
repeatable _Transition_ migrations to no longer be repeatable, execute the _Finalization_
migrations, and then execute any new migrations associated with the code changes that are about to
go out.

The state of migrations in the different directories at any one time is is saved and versioned in
the Migrator Utility which supports the phased migration process in both types of environments.

### Offline environments

The process for offline environments is similar to the always-on ones. However, since they do not
have the constraint of always being on, the _Initial_ and _Transition_ migrations will be run one
after the other:

- Stop the Bitwarden stack as done today
- Start the database
- Run all new migrations in `DbScripts` (both _Finalization_ migrations from the last deploy and any
  _Initial_ migrations from the deploy currently going out)
- Run all _Transition_ migrations
- Restart the Bitwarden stack.

## Rollbacks

In the event the server release failed and needs to be rolled back, it should be as simple as just
re-deploying the previous version again. The database will **stay** in the transition phase until a
patch can be released, and the server can be updated. Once a patch is ready to go out, it is
deployed the _Transition_ migrations are rerun to verify that the DB is in the state that it is
required to be in.

Should a feature need to be completely pulled, a new migration needs to be written to undo the
database changes and the future migration will also need to be updated to work with the database
changes. This is generally not recommended since pending migrations (for other releases) will need
to be revisited.

## Testing

Prior to merging a PR please ensure that the database changes run well on the currently released
version. We currently do not have an automated test suite for this and itâ€™s up to the developers to
ensure their database changes run correctly against the currently released version.

## Further reading

1. [Evolutionary Database Design](https://martinfowler.com/articles/evodb.html) (Particularly
   [All database changes are database refactorings](https://martinfowler.com/articles/evodb.html#AllDatabaseChangesAreMigrations))
2. [The Agile Data (AD) Method](http://agiledata.org/) (Particularly
   [Catalog of Database Refactorings](http://agiledata.org/essays/databaseRefactoringCatalog.html))
3. [Refactoring Databases: Evolutionary Database](https://databaserefactoring.com/)
4. Refactoring Databases: Evolutionary Database Design (Addison-Wesley Signature Series (Fowler))
   ISBN-10: 0321774515

[edd-rfd]:
  https://bitwarden.atlassian.net/wiki/spaces/PIQ/pages/177701412/Adopt+Evolutionary+database+design
