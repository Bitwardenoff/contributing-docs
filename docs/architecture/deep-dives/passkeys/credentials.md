---
sidebar_position: 2
---

# Credentials

This page provides an in-depth look at the FIDO2 credential, which is the technical term used to
refer to a passkey in the context of the FIDO2 standard. On this page they will be referred to as
simply "credentials".

## What is a Credential?

Technically the term "credential" refers to the public/private key pair that is generated by a FIDO2
authenticator. The private key is protected by the authenticator, and the public key is stored
server-side by the Relaying Party (RP). The authenticator uses the private key to sign challenges
from a RP, and the RP uses the public key to verify the signature.

On this page the term "credential" will be used to refer the data structure that is protected by the
authenticator, including the private key, and any metadata that is associated with it.

## Data structure

### Required fields

Credentials are relatively simple data structures and only require the following fields:

- `credentialId` - Binary data sequence that uniquely identifies the credential. It is either a
  random value, or an encrypted version of the credential (see [Storage Modes](#storage-modality)).
- `rpId` - The identifier of the RP for which the credential was created. By default assigned the
  effective domain of the applications origin (ex: bitwarden.com).
- `privateKey` - Private key material, created during the creation ceremony.

### Notable optional fields

- `userHandle` - Binary data sequence that uniquely identifies the user account. This data is opaque
  for anyone other than the RP. It is used to associate a credential with a specific user account.
- `userName` - A human-readable name for the user account. This can be used to display the user
  account in the authenticator's user interface (if supported).

## Storage Modality

### Client-Side Credentials

The credential is stored in persistent storage embedded in the authenticator, client or client
device. This is rapidly becoming a common storage modality, as it is the only way to support synced
credentials across multiple devices. Client-Side storage is required

Hardware security keys also support this storage modality, but they often have a limited storage
capacity (e.g. the YubiKey 5 can hold up to 25 client-side credentials).

### Server-Side Credentials

The credential is stored in a database managed by the RP in an encrypted form that only the original
authenticator can decrypt. This is the traditional storage modality and is often used in 2FA flows.

This enables the authenticator to have unlimited storage capacity for credentials, since the data is
stored by the RP instead of by the authenticator - but it means that a credential stored in this way
must be retrieved from the RP before the authenticator can use it.

## Discoverability

### Non-Discoverable Credentials

This is a credential whose `credentialId` must be provided in `allowCredentials` when calling
`navigator.credentials.get` because it is not client-side discoverable. This is always the case when
the credential is stored server-side, because the RP must first identify the user in order to
discover the `credentialIds` to supply in the `navigator.credentials.get` call.

### Client-Side Discoverable Credentials

:::info

These credentials have been previously known as resident credentials or resident keys. Due to the
phrases `ResidentKey` and `residentKey` being widely used in both the WebAuthn API and also in the
Authenticator Model (e.g. in dictionary member names, algorithm variable names, and operation
parameters) the usage of resident within their names has not been changed for backwards
compatibility purposes.

:::

This credential is usable in authentication ceremonies where the RP does not provide any
`credentialIds`, meaning that the RP does not necessarily need to first identify the user.

As a result, an authenticator that can handle discoverable credentials can create assertion
signatures using just an `rpId`. This enables single-click authentication flows where the returned
assertion data contains everything the PR needs to identify and authenticate the user.

This implies that the source of the credential must be stored either in the authenticator or the
client platform (see [Client Side Credentials](#client-side-credentials)).
